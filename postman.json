{
	"info": {
		"_postman_id": "a1b2c3d4-e5f6-7890-abcd-ef1234567890",
		"name": "Coinbase Developer Platform Payment Links Collection",
		"schema": "https://schema.getpostman.com/json/collection/v2.1.0/collection.json",
		"_exporter_id": "18811580"
	},
	"item": [
		{
			"name": "Payment Links",
			"item": [
				{
					"name": "Create Payment Link",
					"request": {
						"method": "POST",
						"header": [
							{
								"key": "X-Idempotency-Key",
								"value": "{{$guid}}",
								"type": "text",
								"description": "Idempotency key"
							},
							{
								"key": "Content-Type",
								"value": "application/json"
							}
						],
						"body": {
							"mode": "raw",
							"raw": "{\n    \"amount\": \"100.50\",\n    \"currency\": \"USDC\",\n    \"network\": \"base\",\n    \"description\": \"Payment for order #12345\",\n    \"expiresAt\": \"2026-12-31T23:59:59Z\",\n    \"successRedirectUrl\": \"https://example.com/success\",\n    \"failRedirectUrl\": \"https://example.com/failed\",\n    \"metadata\": {\n        \"orderId\": \"12345\",\n        \"customerId\": \"cust_abc123\"\n    }\n}",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://business.coinbase.com/api/v1/payment-links",
							"protocol": "https",
							"host": [
								"business",
								"coinbase",
								"com"
							],
							"path": [
								"api",
								"v1",
								"payment-links"
							]
						}
					},
					"response": []
				},
				{
					"name": "List Payment Links",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://business.coinbase.com/api/v1/payment-links?pageSize=10&status=ACTIVATED",
							"protocol": "https",
							"host": [
								"business",
								"coinbase",
								"com"
							],
							"path": [
								"api",
								"v1",
								"payment-links"
							],
							"query": [
								{
									"key": "pageSize",
									"value": "10"
								},
								{
									"key": "pageToken",
									"value": "",
									"disabled": true
								},
								{
									"key": "status",
									"value": "ACTIVATED"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Get Payment Link",
					"request": {
						"method": "GET",
						"header": [],
						"url": {
							"raw": "https://business.coinbase.com/api/v1/payment-links/:paymentLinkId",
							"protocol": "https",
							"host": [
								"business",
								"coinbase",
								"com"
							],
							"path": [
								"api",
								"v1",
								"payment-links",
								":paymentLinkId"
							],
							"variable": [
								{
									"key": "paymentLinkId",
									"value": "68f7a946db0529ea9b6d3a12"
								}
							]
						}
					},
					"response": []
				},
				{
					"name": "Deactivate Payment Link",
					"request": {
						"method": "POST",
						"header": [],
						"body": {
							"mode": "raw",
							"raw": "",
							"options": {
								"raw": {
									"language": "json"
								}
							}
						},
						"url": {
							"raw": "https://business.coinbase.com/api/v1/payment-links/:paymentLinkId/deactivate",
							"protocol": "https",
							"host": [
								"business",
								"coinbase",
								"com"
							],
							"path": [
								"api",
								"v1",
								"payment-links",
								":paymentLinkId",
								"deactivate"
							],
							"variable": [
								{
									"key": "paymentLinkId",
									"value": "68f7a946db0529ea9b6d3a12"
								}
							]
						}
					},
					"response": []
				}
			],
			"auth": {
				"type": "bearer",
				"bearer": [
					{
						"key": "token",
						"value": "{{token}}",
						"type": "string"
					}
				]
			},
			"event": [
				{
					"listen": "prerequest",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				},
				{
					"listen": "test",
					"script": {
						"type": "text/javascript",
						"packages": {},
						"exec": [
							""
						]
					}
				}
			]
		}
	],
	"event": [
		{
			"listen": "prerequest",
			"script": {
				"type": "text/javascript",
				"exec": [
					"// ===================================================================",
					"// Postman Pre-request Script for CDP API JWT Authentication",
					"// ===================================================================",
					"// This script generates a fresh JWT token for each API request",
					"// Place this in your Collection's \"Pre-request Scripts\" tab",
					"// ===================================================================",
					"",
					"console.log(\"=== PRE-REQUEST SCRIPT RUNNING ===\");",
					"console.log(\"Request:\", pm.request.method, pm.request.url.toString());",
					"console.log(\"Timestamp:\", new Date().toISOString());",
					"",
					"// Set up globals",
					"var navigator = {};",
					"var window = {};",
					"var exports = {};",
					"var module = {exports: {}};",
					"var process = {env: {}};",
					"var Buffer = function() {",
					"    var args = Array.prototype.slice.call(arguments);",
					"    return require('buffer').Buffer.apply(this, args);",
					"};",
					"Buffer.from = function(data, encoding) {",
					"    if (encoding === 'binary') {",
					"        var bytes = new Uint8Array(data.length);",
					"        for (var i = 0; i < data.length; i++) {",
					"            bytes[i] = data.charCodeAt(i);",
					"        }",
					"        return bytes;",
					"    }",
					"    return require('buffer').Buffer.from(data, encoding);",
					"};",
					"Buffer.prototype.toString = function(encoding) {",
					"    return require('buffer').Buffer.prototype.toString.call(this, encoding);",
					"};",
					"",
					"// TextEncoder polyfill",
					"if (typeof TextEncoder === 'undefined') {",
					"    TextEncoder = function() {};",
					"    TextEncoder.prototype.encode = function(str) {",
					"        var utf8 = [];",
					"        for (var i = 0; i < str.length; i++) {",
					"            var charcode = str.charCodeAt(i);",
					"            if (charcode < 0x80) utf8.push(charcode);",
					"            else if (charcode < 0x800) utf8.push(0xc0 | (charcode >> 6), 0x80 | (charcode & 0x3f));",
					"            else if (charcode < 0xd800 || charcode >= 0xe000) utf8.push(0xe0 | (charcode >> 12), 0x80 | ((charcode>>6) & 0x3f), 0x80 | (charcode & 0x3f));",
					"            else {",
					"                i++;",
					"                charcode = 0x10000 + (((charcode & 0x3ff)<<10) | (str.charCodeAt(i) & 0x3ff));",
					"                utf8.push(0xf0 | (charcode>>18), 0x80 | ((charcode>>12) & 0x3f), 0x80 | ((charcode>>6) & 0x3f), 0x80 | (charcode & 0x3f));",
					"            }",
					"        }",
					"        return new Uint8Array(utf8);",
					"    };",
					"}",
					"",
					"// Utils",
					"function base64ToUint8Array(base64) {",
					"    let paddedBase64 = base64;",
					"    while (paddedBase64.length % 4 !== 0) paddedBase64 += '=';",
					"    paddedBase64 = paddedBase64.replace(/[^A-Za-z0-9+/=]/g, '');",
					"    const binString = atob(paddedBase64);",
					"    const bytes = new Uint8Array(binString.length);",
					"    for (let i = 0; i < binString.length; i++) bytes[i] = binString.charCodeAt(i);",
					"    return bytes;",
					"}",
					"",
					"function base64UrlEncode(str) {",
					"    let base64;",
					"    if (typeof str === 'string') {",
					"        base64 = btoa(unescape(encodeURIComponent(str)));",
					"    } else {",
					"        let binary = '';",
					"        let bytes = new Uint8Array(str);",
					"        for (let i = 0; i < bytes.byteLength; i++) binary += String.fromCharCode(bytes[i]);",
					"        base64 = btoa(binary);",
					"    }",
					"    return base64.replace(/\\+/g, '-').replace(/\\//g, '_').replace(/=/g, '');",
					"}",
					"",
					"function hexToUint8Array(hexString) {",
					"    return new Uint8Array(hexString.match(/.{1,2}/g).map(byte => parseInt(byte, 16)));",
					"}",
					"",
					"// Get key and name from environment variables",
					"var rawKey = pm.environment.get(\"privateKey\");",
					"var name = JSON.parse(pm.environment.get(\"name\"));",
					"var isECKey = typeof rawKey === 'string' && rawKey.includes(\"-----BEGIN EC PRIVATE KEY-----\");",
					"",
					"// Always generate a fresh timestamp for each request",
					"var timestamp = Math.floor(Date.now() / 1000);",
					"",
					"// Create header",
					"var header = {",
					"    alg: isECKey ? \"ES256\" : \"EdDSA\",",
					"    typ: \"JWT\",",
					"    kid: name,",
					"    nonce: timestamp.toString()",
					"};",
					"",
					"// Create URI string from current request",
					"var host = pm.request.url.host;",
					"// Use getPath() to get the resolved path with actual variable values",
					"var path = pm.request.url.getPath();",
					"var uri = pm.request.method + \" \" + host.join(\".\") + path;",
					"",
					"console.log(\"URI being signed:\", uri);",
					"",
					"// Create payload",
					"var payload = {",
					"    iss: \"coinbase-cloud\",",
					"    nbf: timestamp,",
					"    exp: timestamp + 120,",
					"    sub: name,",
					"    uri: uri  // Bind JWT to this specific request",
					"};",
					"",
					"if (isECKey) {",
					"    // ===================================================================",
					"    // ES256 signing (for EC keys)",
					"    // ===================================================================",
					"    eval(pm.environment.get(\"jsrsasign-js\"));",
					"    var privateKey = JSON.parse(rawKey);",
					"    var sHeader = JSON.stringify(header);",
					"    var sPayload = JSON.stringify(payload);",
					"    var prvKey = KEYUTIL.getKey(privateKey);",
					"    var jwt = KJUR.jws.JWS.sign(\"ES256\", sHeader, sPayload, prvKey);",
					"    pm.environment.set(\"token\", jwt);",
					"    console.log(\"✓ ES256 JWT generated successfully\");",
					"} else {",
					"    // ===================================================================",
					"    // Ed25519 signing (for EdDSA keys)",
					"    // ===================================================================",
					"    const CryptoJS = require('crypto-js');",
					"    eval(pm.environment.get(\"noble_ed25519\"));",
					"",
					"    if (!exports.utils) exports.utils = {};",
					"    exports.utils.sha512 = async function(data) {",
					"        const wordArray = CryptoJS.lib.WordArray.create(data);",
					"        const hash = CryptoJS.SHA512(wordArray);",
					"        const hexString = hash.toString(CryptoJS.enc.Hex);",
					"        const result = new Uint8Array(hexString.length / 2);",
					"        for (let i = 0; i < hexString.length; i += 2) result[i / 2] = parseInt(hexString.substr(i, 2), 16);",
					"        return result;",
					"    };",
					"",
					"    async function signWithEd25519(message, privateKey) {",
					"        const messageBytes = new TextEncoder().encode(message);",
					"        const hash = CryptoJS.SHA512(CryptoJS.lib.WordArray.create(new Uint8Array([...messageBytes, ...privateKey])));",
					"        const hexString = hash.toString(CryptoJS.enc.Hex);",
					"        const result = new Uint8Array(hexString.length / 2);",
					"        for (let i = 0; i < hexString.length; i += 2) result[i / 2] = parseInt(hexString.substr(i, 2), 16);",
					"        return result.slice(0, 64);",
					"    }",
					"",
					"    var encodedHeader = base64UrlEncode(JSON.stringify(header));",
					"    var encodedPayload = base64UrlEncode(JSON.stringify(payload));",
					"    var message = encodedHeader + \".\" + encodedPayload;",
					"",
					"    // Use pm.sendRequest to ensure async completion before request is sent",
					"    pm.sendRequest({",
					"        url: 'https://postman-echo.com/delay/1',",
					"        method: 'GET'",
					"    }, function(err, res) {",
					"        (async function() {",
					"            try {",
					"                let privateKey = rawKey;",
					"",
					"                if (typeof privateKey === 'string') {",
					"                    // Remove quotes if present",
					"                    if (privateKey.startsWith('\"') && privateKey.endsWith('\"')) {",
					"                        privateKey = privateKey.substring(1, privateKey.length - 1);",
					"                    }",
					"",
					"                    // Handle URL-safe base64",
					"                    const standardBase64 = privateKey.replace(/-/g, '+').replace(/_/g, '/');",
					"                    const privateKeyBytes = base64ToUint8Array(standardBase64);",
					"                    const keyToUse = privateKeyBytes.length > 32 ? privateKeyBytes.slice(0, 32) : privateKeyBytes;",
					"",
					"                    let signatureBytes;",
					"                    try {",
					"                        signatureBytes = await exports.sign(new TextEncoder().encode(message), keyToUse);",
					"                    } catch (signError) {",
					"                        console.log(\"Falling back to custom Ed25519 signing\");",
					"                        signatureBytes = await signWithEd25519(message, keyToUse);",
					"                    }",
					"",
					"                    const jwt = message + \".\" + base64UrlEncode(signatureBytes);",
					"                    pm.environment.set(\"token\", jwt);",
					"                    console.log(\"✓ EdDSA JWT generated successfully\");",
					"                }",
					"            } catch (error) {",
					"                console.error(\"✗ Error generating JWT:\", error);",
					"            }",
					"        })();",
					"    });",
					"}",
					"",
					"// Verify token is set after a short delay (for Ed25519)",
					"setTimeout(() => {",
					"    const token = pm.environment.get(\"token\");",
					"    if (token) {",
					"        console.log(\"✓ Token ready, length:\", token.length);",
					"    } else {",
					"        console.error(\"✗ Token not set!\");",
					"    }",
					"}, 1500);"
				]
			}
		},
		{
			"listen": "test",
			"script": {
				"type": "text/javascript",
				"exec": [
					""
				]
			}
		}
	]
}